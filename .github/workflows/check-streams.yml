name: Check M3U Streams (Geo-aware)

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'

permissions:
  contents: write

jobs:
  check-streams:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests m3u8

      - name: Check Streams
        run: |
          python - <<'EOF'
          import requests
          import os
          from datetime import datetime
          import re
          import time

          def get_runner_location():
              try:
                  ip_info = requests.get('https://ipinfo.io/json', timeout=5).json()
                  return {
                      "ip": ip_info.get('ip', 'Unknown'),
                      "country": ip_info.get('country', 'Unknown'),
                      "region": ip_info.get('region', 'Unknown'),
                      "city": ip_info.get('city', 'Unknown'),
                      "org": ip_info.get('org', ''),
                  }
              except Exception:
                  return {
                      "ip": "Unknown",
                      "country": "Unknown",
                      "region": "Unknown",
                      "city": "Unknown",
                      "org": "",
                  }

          def get_geo_suggestions(status_code, country_code):
              """Suggest likely working regions based on stream country and error type"""
              geo_hints = {
                  'UK': ['United Kingdom', 'Ireland'],
                  'US': ['United States', 'Canada', 'Mexico'],
                  'CA': ['Canada', 'United States'],
                  'AU': ['Australia', 'New Zealand'],
                  'AE': ['United Arab Emirates', 'Saudi Arabia', 'Qatar', 'Kuwait', 'Bahrain'],
                  'AR': ['Argentina', 'Chile', 'Uruguay', 'Paraguay'],
                  'IE': ['Ireland', 'United Kingdom'],
                  'ZA': ['South Africa', 'Botswana', 'Namibia'],
                  'YE': ['Yemen', 'Saudi Arabia', 'Oman'],
                  'NZ': ['New Zealand', 'Australia']
              }
              
              if status_code == 403:
                  return geo_hints.get(country_code, [f'Likely {country_code} region only'])
              return []

          runner_loc = get_runner_location()

          def check_stream(url, timeout=5):
              """Check if a stream URL is accessible and categorize failures, with geo-block hint."""
              try:
                  headers = {
                      'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                      'Accept': '*/*',
                      'Accept-Language': 'en-US,en;q=0.9',
                      'Accept-Encoding': 'gzip, deflate',
                      'Connection': 'keep-alive',
                      'Referer': 'https://github.com/'
                  }
                  # First try HEAD request
                  try:
                      response = requests.head(url, timeout=timeout, headers=headers, allow_redirects=True)
                      if response.status_code < 400:
                          return {"status": "working", "code": response.status_code, "error": None}
                  except:
                      pass

                  # If HEAD fails, try GET with stream
                  response = requests.get(url, timeout=timeout, headers=headers, stream=True, allow_redirects=True)
                  geo_hint = ""
                  if response.status_code < 400:
                      try:
                          next(response.iter_content(chunk_size=1024), None)
                          return {"status": "working", "code": response.status_code, "error": None}
                      except:
                          return {"status": "stream_error", "code": response.status_code, "error": "Stream not readable"}
                  else:
                      if response.status_code == 403:
                          # Try to detect geo-block from the response body
                          try:
                              text = response.text.lower()
                              if any(s in text for s in ["not available in your country", "geo", "region", "not available in your location", "outside your region", "not available in your territory"]):
                                  geo_hint = "geo-blocked"
                              else:
                                  geo_hint = "403 forbidden"
                          except:
                              geo_hint = "403 forbidden"
                          return {
                              "status": "access_denied",
                              "code": 403,
                              "error": "Access denied (possibly geo-blocked)",
                              "geo_hint": geo_hint
                          }
                      elif response.status_code == 404:
                          return {"status": "not_found", "code": 404, "error": "Stream not found"}
                      elif response.status_code in [500, 502, 503, 504]:
                          return {"status": "server_error", "code": response.status_code, "error": "Server error"}
                      else:
                          return {"status": "http_error", "code": response.status_code, "error": f"HTTP {response.status_code}"}
              except requests.exceptions.Timeout:
                  return {"status": "timeout", "code": None, "error": "Connection timeout"}
              except requests.exceptions.ConnectionError as e:
                  error_str = str(e)
                  if "Name or service not known" in error_str or "Failed to resolve" in error_str:
                      return {"status": "dns_error", "code": None, "error": "DNS resolution failed"}
                  elif "Connection refused" in error_str:
                      return {"status": "connection_refused", "code": None, "error": "Connection refused"}
                  else:
                      return {"status": "connection_error", "code": None, "error": "Connection error"}
              except Exception as e:
                  return {"status": "unknown_error", "code": None, "error": str(e)[:100]}

          def parse_m3u(file_path):
              """Parse M3U file and extract stream information"""
              if not os.path.exists(file_path):
                  print(f"File not found: {file_path}")
                  return []

              streams = []
              try:
                  with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                      lines = f.readlines()
              except Exception as e:
                  print(f"Error reading {file_path}: {str(e)}")
                  return []

              # Enhanced keywords for filtering out movies/series
              exclude_keywords = [
                  # Movies
                  'movie', 'film', 'cinema', 'bollywood', 'hollywood', 'nollywood',
                  # TV Series
                  'serie', 'series', 'season', 'episode', 'drama', 'comedy', 'action', 
                  'thriller', 'horror', 'romance', 'documentary', 'animation', 'cartoon', 
                  'anime', 'sitcom', 'reality', 'talk show', 'tv show', 'tvshow',
                  # Streaming services
                  'netflix', 'amazon', 'hulu', 'disney', 'marvel', 'hbo', 'showtime',
                  # Common movie/series indicators
                  '(20', '(19', 'imdb', 'trailer', 'preview', 'full movie', 'watch online'
              ]
              
              # Also exclude by group names that clearly indicate movies/series
              exclude_groups = [
                  'movie', 'movies', 'film', 'films', 'cinema', 'series', 'tv series', 
                  'drama', 'comedy', 'action', 'horror', 'thriller', 'romance',
                  'documentary', 'animation', 'cartoon', 'anime', 'bollywood', 
                  'hollywood', 'nollywood', 'netflix', 'amazon prime', 'hulu', 'disney+'
              ]

              for i in range(len(lines)):
                  line = lines[i].strip()
                  if line.startswith('#EXTINF'):
                      try:
                          group_match = re.search(r'group-title="([^"]*)"', line)
                          group = group_match.group(1) if group_match else "No Group"
                          name_part = line.split(',')[-1].strip()
                          name = name_part if name_part else "Unknown Channel"
                          
                          # Skip if it looks like a movie/series based on name or group
                          name_lower = name.lower()
                          group_lower = group.lower()
                          
                          # Check if name or group contains movie/series keywords
                          is_movie_series = (
                              any(keyword in name_lower for keyword in exclude_keywords) or 
                              any(keyword in group_lower for keyword in exclude_keywords) or
                              group_lower in exclude_groups
                          )
                          
                          # Skip movie/series content
                          if is_movie_series:
                              continue
                              
                          if i + 1 < len(lines):
                              url = lines[i + 1].strip()
                              if url and not url.startswith('#') and ('http' in url or 'rtmp' in url):
                                  # Skip URLs ending with video file extensions (movies/series)
                                  if url.endswith(('.mkv', '.mp4', '.avi', '.mov', '.wmv', '.flv', '.webm', '.m4v')):
                                      continue
                                  streams.append({
                                      'name': name,
                                      'url': url,
                                      'group': group
                                  })
                      except Exception as e:
                          print(f"Error parsing line {i}: {str(e)}")
                          continue
              
              print(f"Filtered to {len(streams)} channel streams (excluded movies/series)")
              return streams

          total_streams = 0
          working_streams = 0
          categorized_failures = {
              'access_denied': [],
              'timeout': [],
              'dns_error': [],
              'not_found': [],
              'server_error': [],
              'connection_error': [],
              'stream_error': [],
              'http_error': [],
              'unknown_error': []
          }
          checked_streams = 0

          m3u_files = [
              'channel playlist.m3u'
          ]

          print("Starting stream check...")

          for m3u_file in m3u_files:
              print(f"Processing {m3u_file}...")
              try:
                  streams = parse_m3u(m3u_file)
                  file_total = len(streams)
                  total_streams += file_total
                  file_working = 0

                  print(f"Found {file_total} streams in {m3u_file}")

                  for i, stream in enumerate(streams):
                      checked_streams += 1
                      print(f"Checking stream {checked_streams}/{total_streams}: {stream['name'][:50]}...")

                      result = check_stream(stream['url'])

                      if result['status'] == 'working':
                          working_streams += 1
                          file_working += 1
                      else:
                          failure_info = {
                              'name': stream['name'],
                              'group': stream['group'],
                              'url': stream['url'][:100] + '...' if len(stream['url']) > 100 else stream['url'],
                              'file': m3u_file,
                              'error': result['error'],
                              'code': result['code'],
                              'geo_hint': result.get('geo_hint', ''),
                              'runner_country': runner_loc['country'],
                              'runner_ip': runner_loc['ip'],
                              'runner_city': runner_loc['city'],
                              'runner_org': runner_loc['org'],
                          }
                          if result['status'] in categorized_failures:
                              categorized_failures[result['status']].append(failure_info)
                          else:
                              categorized_failures['unknown_error'].append(failure_info)

                      time.sleep(0.1)

                  print(f"File {m3u_file}: {file_working}/{file_total} working streams")

              except Exception as e:
                  print(f"Error processing {m3u_file}: {str(e)}")

          total_failures = sum(len(failures) for failures in categorized_failures.values())
          working_percentage = (working_streams / total_streams * 100) if total_streams > 0 else 0

          # Generate report
          report = f"""# üì∫ M3U Stream Status Report

          **Generated on:** {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC  
          **GitHub Actions Runner Location:** {runner_loc['country']} ({runner_loc['city']})  
          **Runner public IP:** {runner_loc['ip']}  
          **Runner network:** {runner_loc['org']}

          ## üìä Summary

          | Metric | Count | Percentage |
          |--------|-------|------------|
          | **Total Streams** | {total_streams} | 100% |
          | **‚úÖ Working Streams** | {working_streams} | {working_percentage:.1f}% |
          | **‚ùå Failed Streams** | {total_failures} | {100-working_percentage:.1f}% |

          ## üìÅ Files Processed
          """
          for m3u_file in m3u_files:
              if os.path.exists(m3u_file):
                  file_streams = parse_m3u(m3u_file)
                  report += f"- `{m3u_file}`: {len(file_streams)} streams\n"
              else:
                  report += f"- `{m3u_file}`: **File not found**\n"

          failure_categories = {
              'access_denied': ('üö´ Access Denied', 'Likely geo-blocked or requires authentication'),
              'timeout': ('‚è±Ô∏è Connection Timeouts', 'Server too slow to respond or overloaded'),
              'dns_error': ('üåê DNS Resolution Failures', 'Domain name cannot be resolved'),
              'not_found': ('‚ùì Not Found (404)', 'Stream URL no longer exists'),
              'server_error': ('üí• Server Errors (5xx)', 'Server-side issues'),
              'connection_error': ('üîó Connection Errors', 'Network connectivity issues'),
              'stream_error': ('üì∫ Stream Reading Errors', 'Stream exists but content unreadable'),
              'http_error': ('üåç Other HTTP Errors', 'Various HTTP status codes'),
              'unknown_error': ('‚ùì Unknown Errors', 'Unexpected errors')
          }

          if total_failures > 0:
              report += f"""
          ## üìã Failure Analysis ({total_failures} total failures)
          """
              for category, failures in categorized_failures.items():
                  if failures:
                      title, description = failure_categories[category]
                      report += f"""### {title} ({len(failures)} streams)
          *{description}*

          | Channel Name | Group | File | Error Details | Stream Country | Likely Working Regions | Runner Country | Code |
          |--------------|-------|------|--------------|----------------|----------------------|---------------|------|
          """
                      for stream in failures:
                          name = stream['name'].replace('|', '\\|').replace('\n', ' ').strip()
                          group = stream['group'].replace('|', '\\|').replace('\n', ' ').strip()
                          file_name = stream['file'].replace('|', '\\|')
                          error = stream['error'].replace('|', '\\|') if stream['error'] else 'Unknown'
                          code = stream['code'] if stream['code'] else 'N/A'
                          stream_country = stream.get('stream_country', 'Unknown')
                          likely_regions = stream.get('likely_regions', 'Unknown')
                          runner_country = stream.get('runner_country', 'US')
                          report += f"| {name} | {group} | {file_name} | {error} | {stream_country} | {likely_regions} | {runner_country} | {code} |\n"
                      report += "\n"
          else:
              report += """
          ## üéâ All Streams Working!

          Congratulations! All streams are currently accessible from this runner location.
          """

          report += f"""
          ## üìà Geographic Notes

          - Tests run from **GitHub Actions infrastructure** (current runner country: {runner_loc['country']})
          - "Access Denied" errors may indicate geo-restrictions for this region
          - Some streams may work from different geographic locations
          - DNS errors suggest the streaming service may be down entirely
          - Timeout errors often indicate server overload or slow response

          ## üìù Technical Details

          - **User-Agent:** Modern browser simulation for better compatibility
          - **Timeout:** 15 seconds per stream
          - **Method:** HEAD request first, then GET with stream verification
          - **Retry Logic:** Single attempt per stream to avoid rate limiting
          - **Headers:** Include Accept-Language and Referer for better success rates

          ---
          *Last updated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC*
          *Report generated automatically by GitHub Actions*
          """

          try:
              with open('report.md', 'w', encoding='utf-8') as f:
                  f.write(report)
              print("Report generated successfully!")
          except Exception as e:
              print(f"Error writing report: {str(e)}")

          print(f"Final Summary: {working_streams}/{total_streams} streams working ({working_percentage:.1f}%)")
          EOF

      - name: Commit and push report
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "github-actions[bot]"
          
          # Check if there are changes to commit
          git add report.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          # Pull any remote changes first to avoid conflicts
          git stash push -m "temp stash for rebase"
          git pull --rebase origin main
          git stash pop
          
          # Add files again after stash pop and commit
          git add report.md
          git commit -m "üìä Update stream status report - $(date -u '+%Y-%m-%d %H:%M UTC')"
          
          # Push with retry logic in case of race conditions
          for i in {1..3}; do
            if git push; then
              echo "Successfully pushed on attempt $i"
              break
            else
              echo "Push failed on attempt $i, retrying..."
              git pull --rebase origin main
              sleep 2
            fi
            if [ $i -eq 3 ]; then
              echo "Failed to push after 3 attempts"
              exit 1
            fi
          done
