# This is a basic workflow to help you get started with Actions
name: Fetch TV-FM Files

on:
  schedule:
    - cron: '30 * * * *'
  workflow_dispatch: {} # Enables manual triggering

permissions:
  contents: write

jobs:
  download_and_commit:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download unwrapped M3U Plus file
        run: wget "${{ secrets.IPTV_M3U_URL }}" -O "unwrapped.m3u"

      - name: Download EPG XML file
        run: wget "${{ secrets.IPTV_EPG_URL }}" -O "channel playlist.xml"

      - name: Transform URLs to wrapped format
        env:
          IPTV_USERNAME: ${{ secrets.IPTV_USERNAME }}
          IPTV_PASSWORD: ${{ secrets.IPTV_PASSWORD }}
        run: |
          python3 << 'EOF'
          import base64
          import re
          import json
          import urllib.parse
          import os

          def wrap_m3u_urls(input_file, output_file):
              """
              Reads an unwrapped M3U file and transforms stream URLs into the proxy-wrapped format.
              """
              # Get credentials from environment variables
              username = os.environ.get('IPTV_USERNAME')
              password = os.environ.get('IPTV_PASSWORD')
              
              if not username or not password:
                  print("Error: IPTV credentials not found in environment variables")
                  return
              
              # Fixed parameters based on analysis and user credentials
              PREFIX = f"http://alt.xtream-ie.org/{username}/{password}/1"
              SUFFIX = "/fast"
              
              # Groups that need /#.mkv added to URLs
              MKV_GROUPS = {
                  "NETFLIX", "Disney+", "PRIME VIDEO", "HBO MAX", "Peacock TV", 
                  "Paramount+", "SONY Pictures Core", "STARZ", "AMC+", "BritBox", 
                  "Apple TV+", "Others", "Hallmark+", "stan.", "FMTV+", "RTÃˆ PLAYER", 
                  "Angel Studios", "PBS", "DOCPLAY", "CBC Gem", "Peacock TV (Shows)", 
                  "SONY Pictures Core (Shows)", "Stan.", "Studiocanal Presents"
              }
              
              # Regex to find the CUID value from the #EXTINF line
              CUID_PATTERN = re.compile(r'CUID=\"(\d+)\"')
              # Regex to find the group-title value
              GROUP_PATTERN = re.compile(r'group-title=\"([^\"]+)\"')
              
              print(f"Starting M3U transformation: {input_file} -> {output_file}")

              try:
                  with open(input_file, 'r', encoding='utf-8') as infile, \
                       open(output_file, 'w', encoding='utf-8') as outfile:
                      
                      # Read all lines
                      lines = infile.readlines()
                      
                      # Check for M3U header and write it with EPG URL
                      if not lines or lines[0].strip() != "#EXTM3U":
                          print("Error: Input file is missing the '#EXTM3U' header.")
                          return

                      # Write the header with EPG URL
                      outfile.write('#EXTM3U url-tvg="https://tinyurl.com/FMTV-L1VE-EPG-XML"\n') 
                      
                      i = 1 # Start processing from the second line
                      while i < len(lines):
                          extinf_line = lines[i].strip()
                          
                          # If it's an #EXTINF line, the next line should be the URL
                          if extinf_line.startswith("#EXTINF"):
                              # 1. Write the #EXTINF line immediately
                              outfile.write(extinf_line + '\n')
                              
                              # Ensure a URL line exists before proceeding
                              if i + 1 >= len(lines):
                                  print(f"Warning: Missing URL after {extinf_line}. Skipping.")
                                  i += 1
                                  continue

                              url_line = lines[i+1].strip()
                              
                              # Skip empty URL lines
                              if not url_line:
                                  outfile.write(url_line + '\n')
                                  i += 2
                                  continue
                              
                              # 2. Extract CUID and group-title
                              cuid_match = CUID_PATTERN.search(extinf_line)
                              group_match = GROUP_PATTERN.search(extinf_line)
                              
                              if not cuid_match:
                                  # If CUID is missing, write the original URL and continue
                                  outfile.write(url_line + '\n')
                                  i += 2
                                  continue

                              cuid = int(cuid_match.group(1))
                              
                              # Check if this channel belongs to a group that needs /#.mkv
                              needs_mkv = False
                              if group_match:
                                  group_title = group_match.group(1)
                                  needs_mkv = group_title in MKV_GROUPS
                              
                              # 3. Build the JSON payload: {"url":"<ORIGINAL_URL>","id":<CUID>}
                              payload_data = {"url": url_line, "id": cuid}
                              payload_str = json.dumps(payload_data)
                              
                              # 4. Base64 Encode the JSON payload
                              encoded_payload = base64.b64encode(payload_str.encode('utf-8')).decode('utf-8')
                              
                              # 5. URL-safe encode the result
                              url_safe_payload = encoded_payload.replace('=', '%3D')
                              
                              # 6. Construct the wrapped URL with /#.mkv after /fast if needed
                              if needs_mkv:
                                  wrapped_url = f'{PREFIX}{url_safe_payload}{SUFFIX}/#.mkv'
                              else:
                                  wrapped_url = f'{PREFIX}{url_safe_payload}{SUFFIX}'
                              
                              outfile.write(wrapped_url + '\n')
                              
                              i += 2 # Move to the next #EXTINF line
                          else:
                              # Write any other lines (like empty lines or other tags) as is
                              outfile.write(lines[i]) 
                              i += 1
                              
                  print("Transformation complete.")

              except FileNotFoundError:
                  print(f"Error: File {input_file} was not found.")
              except Exception as e:
                  print(f"An unexpected error occurred: {e}")

          # Execute the transformation
          wrap_m3u_urls('unwrapped.m3u', 'channel playlist.m3u')
          EOF

      - name: Add files to Git
        run: |
          git add "channel playlist.m3u"
          git add "channel playlist.xml"

      - name: Check for changes before commit
        id: changes
        run: |
          if git diff --cached --quiet; then
            echo "no changes"
            echo "changes_detected=false" >> $GITHUB_ENV
          else
            echo "changes_detected=true" >> $GITHUB_ENV
          fi

      - name: Commit changes if any
        if: env.changes_detected == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "github-actions[bot]"
          git commit -m "Updated channel playlist files (M3U with wrapped URLs and EPG XML)"

      - name: Force push changes if commit happened
        if: env.changes_detected == 'true'
        run: |
          git push origin main --force
